# 类加载

## 类的生命周期、加载过程

+ 加载 Loading
+ 链接 Linking
    + 验证 Verification
    + 准备 Preparation
    + 解析 Resolution
+ 初始化 Initialization
    + 使用 Using
    + 卸载 Unloading

### 加载

第一步，完成下面3件事

1. 通过全类名获取定义此类的二进制字节流
2. 将字节流所代表的静态存储结构转换为方法去的运行时数据结构
3. 在内存中生成一个代表该类的Class对象，作为方法去这些数据的访问入口。

加载有类加载器完成，具体哪个类加载器完成，由双亲委派模型决定。  
每个Java类都有一个引用指向加载他的ClassLoader。  
数组类不是通过ClassLoader创建的，而是JVM需要的时候自动创建的。

加载阶段尚未结束，链接阶段可能就已经开始。

### 链接

#### 验证

确保Class文件的字节流信息符合Java虚拟机规范的全部约束要求，防止恶意代码的执行。

不过验证阶段不是非必须，如果代码被反复验证过，可以使用参数`-Xverify:none`关闭大部分的
类验证措施，以缩短类加载的时间。

由四个检验阶段：

+ 文件格式验证-Class文件格式检查
+ 元数据验证-字节码语义检查
+ 字节码验证-程序语义检查
+ 符号引用验证-类的正确性检查

#### 准备

为类变量分配内存，并设置类变量初始值，都在方法区中分配

+ 仅包括类变量即静态变量，不包括实例变量
+ jdk7之后，hotspot类变量和Class对象一起存放在堆中
+ 通常情况下设置的是数据类型默认的零值，比如`public static int value=111`赋值的是0
+ 如果加上了final，`public static final int value=111`赋值就是111

#### 解析

虚拟机将常量池内的符号引用替换为直接引用  
得到类、字段、方法在内存中的指针或者偏移量

### 初始化

执行初始化方法`<clinit>()`，这一步JVM才开始真正之心该类中定义的Java程序代码。

`<clinit>()`是编译后自动生成的

对于初始化阶段，JVM严格规范了只有6种情况，必须对类进行初始化  
只有主动去使用类才会初始化类

1. 遇到new\getstatic putstatic\invokestatic这四条字节码指令，

+ new：程序创建一个类的实例对象
+ getstatic：程序访问类的静态变量（非静态常量，常量会被加载到运行时常量池）
+ putstatic：程序给类的静态变量赋值
+ invokestatic：调用类的静态方法

2. 使用反射，如果类没初始化需要初始化
3. 初始化一个类，如果父类未初始化，先初始化父类
4. 虚拟机启动时先初始化主类（包含main方法的类）
5. MethodHandle 和 VarHandle 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用，就必须先使用 findStaticVarHandle 来初始化要调用的类。
6. 一个接口中定义了jdk8新加入的default方法，如果这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

### 卸载
类的class对象被GC
+ 类的所有实例对象都被GC，堆不存在该类的实例对象
+ 类没有在其他任何地方被引用
+ 类的类加载器的实例被GC

## 类加载器
+ 负责加载类的对象
+ 每个类都有一个引用指向加载它的ClassLoader
+ 数组类不是通过ClassLoader创建的，是由JVM直接生成的

简单来说，类加载器的主要作用就是加载类的字节码（.class文件）到JVM中（在内存中生成一个代表该类的Class对象）。
字节码可以事Java源程序经过javac编译而来，也可以事通过工具动态生成或者通过网络下载而来。  

类加载其还可以加载文本、图像、配置文件、视频等文件资源。

### 加载规则
+ JVM启动并不会一次性加载所有的类，根据需要动态加载。
+ 已加载的类会放在ClassLoader中，类加载时，先判断，已有的直接返回，没有再加载。

### 内置的类加载器
+ 启动类加载器-BootstrapClassLoader
  + 最顶层的加载类，c++实现
  + 通常表示为null，没有父级
  + 加载jdk内部的核心类库`lib`下的rt.jar、resources.jar、charsets.jar等 jar
  + 加载被`-Xbootclasspath`参数指定的路径下的类
+ 扩展类加载器-ExtensionClassLoader
  + 加载jdk内部的核心类库`lib/ext`下的jar
+ 应用程序类加载器-AppClassLoader

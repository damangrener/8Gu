### 线程和进程
+ 一个进程中可以有多个线程
+ 多个线程共享进程的堆和方法区，每个线程有自己的程序计数器、虚拟机栈和本地方法栈。

#### 程序计数器为什么是私有的
为了线程切换后能恢复到正确的执行位置
+ 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。如顺序、选择、循环、异常处理。
+ 多线程的情况下，程序计数器用于记录当前线程执行的位置，当线程切换回来继续运行。

#### 虚拟机栈和本地方法栈为什么是私有的？
为了保证线程中的局部变量不被别的线程访问到。
+ 虚拟机栈：
    + 每个Java方法执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。
    + 从方法调用至完成，对应着一个栈帧在Java虚拟机中入栈出栈的过程
    + 为Java方法（字节码）服务
+ 本地方法栈：
    + 和虚拟机栈类似
    + 为使用到的Native方法服务

### 一句话 堆和方法区
堆和方法区是所有线程共享的资源。
+ 堆
    + 进程中最大的一块内存
    + 用于存放新创建的对象
+ 方法区
    + 存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等

### 多线程带来的问题
内存泄漏、死锁、线程不安全
#### 线程安全？
线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其正确性和一致性的描述。

### 创建线程
+ 继承Thread，重写run()
+ 实现Runnable，重写run()
+ 实现Callable，这种方式可以拿到线程执行完的返回值
+ 使用ExecutorService线程池创建
+ 使用FutureTask，匿名的方式创建Callable

创建线程的方式只有一种`Thread.start()`，其他是创建线程体，仅仅是一个任务。  
线程是执行线程体的容器，线程体是一个可运行的任务。

### 线程的生命周期和状态
+ NEW：初始状态，被创建出来，但没被调用`start()`
+ RUNNABLE：运行状态，调用了`start()`
+ BLOCKED：阻塞状态，等待锁释放
+ WAITING：等待状态，该线程需等待其他线程做出一些特定动作（通知或中断）
+ TIME_WAITING：超时等待状态，在指定的时间后自行返回，而不是像WAITING一样一直等待
+ TERMINATED：终止状态，运行完毕

### 线程上下文切换
线程在执行过程中会有自己的运行条件和状态，比如程序计数器、栈信息等。  
频繁切换会造成整体效率低下，因为每次保存信息，恢复信息会占用CPU、内存处理。

### 线程死锁
多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。
#### 产生死锁必要条件
+ 互斥条件：该资源任意一个时刻只由一个线程占用
+ 请求与保持条件：线程在等待其他资源是保持对已获取资源的持有
+ 不可剥夺条件：已经分配给线程的资源不能被强行剥夺，只能由持有资源的线程自愿释放
+ 循环等待条件：存在一个循环链，每个线程都在等待下一个线程所持有的资源

### sleep和wait
都可以暂停线程的执行  
区别：
+ sleep没有释放锁，wait释放了锁
+ wait用于线程间交互、通信，sleep用于暂停执行
+ wait被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify或者notifyAll。
+ sleep执行完后，线程自动苏醒
+ sleep是Thread的静态本地方法，wait是Object的本地方法

### 可以直接调用Thread的run方法么
直接执行`run()`，会把`run()`当成main线程下的一个普通方法去执行

调用`start()`可启动线程，并使线程进入就绪状态，直接执行`run()`不会以多线程的方式执行

## JMM Java内存模型
对于一个共享变量，当另一个线程对这个共享变量执行写操作后，这个线程对这个共享变量的可见性。

### 缓存
+ CPU缓存
  + 解决CPU处理速度和内存处理速度不对等的问题
+ 内存缓存
  + 解决硬盘访问速度过慢的问题


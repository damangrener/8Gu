### 数据库三大范式
+ 列不可分
  + 每个表的每个字段都只包含一个值，不可再分
+ 属性字段完全依赖于主键
+ 属性之间没有传递依赖

好的，让我更详细地解释第二范式（2NF）和第三范式（3NF）：
  
第二范式（2NF）要求在满足第一范式的基础上，非主键属性必须完全依赖于候选键，而不是部分依赖于候选键。具体来说，一个表在满足第一范式的前提下，如果其候选键（即唯一标识每一行的键）由多个字段组成，那么非主键属性必须依赖于所有这些字段的组合，而不仅仅是其中的一部分。这样做可以避免数据冗余和不一致性。
举个例子，假设有一个订单表，候选键由订单号（OrderID）和产品号（ProductID）组成，而产品价格（Price）只依赖于产品号，而不依赖于订单号。那么这个表就不满足第二范式，因为非主键属性（产品价格）只依赖于候选键的一部分（产品号），而不是完全依赖于候选键。
  
第三范式（3NF）要求在满足第二范式的基础上，非主属性之间不能存在传递依赖。也就是说，如果 A->B->C，则 A 和 C 之间不能有直接依赖。这样可以进一步减少数据冗余和提高数据的一致性。

举个例子，假设有一个员工表，包含员工号（EmployeeID）、员工姓名（EmployeeName）和部门号（DepartmentID）。如果在这个表中除了员工号和部门号之外，还包含了部门名称（DepartmentName），那么就存在传递依赖：员工号->部门号->部门名称。这样的设计就不符合第三范式。解决方法是将部门名称移除到另一个表中，这样每个非主属性都只依赖于主键。
希望这样更清楚了解第二范式和第三范式的概念。

### 事务的四大特性
ACID
+ 原子性-Atomicity 
  + 事务最基本的操作单元 
  + 要么全部成功，要么全部失败，不会结束在某个中间环节
  + 事务在执行过程 中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样
+ 一致性-Consistency
  + 一个事务执行之前和执行之后数据库都必须属于一致性状态
  + 如果成功，系统所有变化都将正确应用，系统处于有效状态
  + 如果出现错误，系统中所有变化将自动回滚，系统返回原始状态
+ 隔离性-Isolation
  + 在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间
  + 由并发事务所作的修改必须与任何其他并发事务所作的修改隔离。
  + 事务查看数据更新是，数据所处的状态要么是另一事务修改他之前的状态，要么是另一事务修改它之后的状态，不会看到中间状态
+ 持久性-Durability
  + 只要事务成功，对数据库做的更新就必须永久保存下来。

### 事务的隔离级别
+ 读未提交
  + 允许一个事务读取另一个事务未提交的数据
  + 隔离级别最低
  + 脏读：读取其他事务未提交的数据
+ 读已提交
  + 一个事务只能读取到其他事务已经提交的数据
  + 避免脏读，导致不可重复读：在同一个食物中，读取同一行数据时，由于其他事务的更新导致读取的数据不一致
+ 可重复读
  + 在同一个事务中，多次读取同一行数据是，会得到相同的结果，即使其他事务对该行数据进行更新也不影响
  + 避免不可重复读，导致幻读：在同意事务中，多次查询同一范围的数据，由于其他事务的插入或删除，查询结果集不一样
+ 串行化
  + 最高的隔离级别
  + 确保每个事务都像在独立运行，强制事务串行执行
  + 避免脏读、不可重复读、幻读
  + 性能开销大

#### 默认隔离级别
+ MySQL 可重复读
+ Oracle 读已提交

### drop\delete\truncate的区别
+ drop、truncate属于DDL
+ delete DML
+ 执行速度drop>truncate>delete
  + delete执行产生binlog日志，日志记录消耗时间，但是方便数据回滚
  + truncate不产生数据库日志，把表的自增值充值，索引恢复到初始大小
  + drop把表占用的空间全部释放